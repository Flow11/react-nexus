React on Rails API Reference
============================

0. Assumptions
0. `R` Top-level API
0. `R.Debug`
0. `R.App`
0. `R.Client`
0. `R.RenderServer`
0. `R.Flux`
0. `R.Store`
0. `R.EventEmitter`
0. `R.Dispatcher`
0. `R.Root`
0. `R.Component`
0. `R.Style`
0. `R.Stylesheet`
0. `R.Uplink`
0. `R.SimpleUplinkServer`
0. `R.Lock`
0. `React.Children` (extensions)
0. `React.createClass` (extensions)
0. `R.Pure`
0. `R.Async`
0. `R.Animate`
0. `R.Query` (`R.$`)
0. `R.Router`
0. `R.History`
0. `R.Localize`
0. `R.Window`
0. `R.XWindow`
0. `R.Cordova`


### Assumptions

The magic of `React on Rails` essentially relies on the same assumptions as `React`.
However, it makes the additional following assumptions:

- Client is run from an HTML page generated by render server.
- Components don't trigger side-effects (timeouts, etc.) unless they explicitly clean after themselves
- All components code is isomorphic, except when its not (eg. reaction to DOM events, `componentDidMount`, etc.)
- Don't mess with the frameworks' internals (anything prefixed with either `_` or `__`)
- Client `guid`s should be kept secret. Don't share any client `guid` publicly, if you need to identify client amongst them
hash their guids first.
- Installing `R` using `R.install(params)` should be the or very close to the first line of your entry points, since it must patch React internals
before any call to `React.createClass` is performed.

### Top-level API

The top-level API regroups several cross-concern utilities, and the `install` static method.

#### `R.install(Object params)`
Sets up the environment for `React on Rails`.
It requires reference to the `React` object and a reference to the `instantiateReactComponent` methods.
You must call this method before any call to `React.createClass`.
- `params.React: Object`: typically the value of `require("react")`.
- `params.instantiateReactComponent: Function`: typically the value of `require("react/lib/instiantiateReactComponent")
- `params.mode: String` (Optional) Either `production` or `development`. Defaults to `development`.

`install` dynamically injects a reference to the React object, and therefore the package doesn't have `react` as an explicit `npm`
dependency. However, it can only be used in a program which effectively requires `react` and pass it as `param.React`.

#### `R.scope(Function fn, Object ctx): Function`
Faster implementation of `Function.prototype.bind` for the special case where no arguments are bound, only
the context. See [this jsperf](http://jsperf.com/bind-vs-scope-perf).

#### `R.record(String key, Any val): Object`
Returns an Object with a single key-value pair.

#### `R.noopThunk(): Function(Function)`
Returns a thunk that defers its resolution to the next macrotask tick.

#### `R.timeoutThunk(Number delay): Function(Function)`
Returns a thunk that defers its resolution of a given delay.

#### `R.constantThunk(Any val): Function(Function)`
Returns a thunk that defers its resolution to the next macrotask tick and resolve to the given value.

#### `R.callWith(...args): Function(Function)`
Returns a callback that applies the arguments passed to `R.callWith` to its unique arguments.
Useful when iterating a collection of functions.

#### `R.isServer(): Boolean`
Returns true iff the current runtime is in the server (node).

#### `R.isClient(): Boolean`
Returns true iff the current runtime is a browser.

#### `R.ifServer(Function fn)`
Runs `fn` and returns its value iff the runtime is in the server. Otherwise, returns `undefined`.

#### `R.ifClient(Function fn)`
Runs `fn` and returns its value iff the runtime is in the browser. Otherwise, returns `undefined`.

#### `R.startsWith(String str, String prefix): Boolean`
Return true iff `str` starts with `prefix`.

#### `R.hash(String str ): String`
Returns a cryptographically secure hash of `str`. See [`sha256`](https://www.npmjs.org/package/sha256).

#### `R.guid(String prefix=""): String`
Returns a freshly generated [GUID](http://en.wikipedia.org/wiki/Globally_unique_identifier), optionally prefixed by `prefix`.
It is used internally for generating unique client ids.

#### `R.Base64.encode(String s): String`
Encodes `s` to from utf-8 to Base64.

#### `R.Base64.decode(String s): String`
Decodes `s` from Base64 to utf-8.

### `R.Debug`
Debugging utilities, yielding both safe assertions during development and fast execution in production, without changing a single line of code.

#### `R.Debug.setMode(String mode)`
Sets the internal mode and `process.env.NODE_ENV` to `mode` which should be either `development` or `production`.
In `development` mode, Promises and immediates (used by `regenerator`) yield long stack traces.

#### `R.Debug.isDev(): Boolean`/`R.Debug.isProd(): Boolean`
Booleans for the current mode.

#### `R.Debug.dev(Function fn)/R.Debug.prod(Function fn)`
Runs `fn`, only if the current mode is `development` (for `R.Debug.dev`) or `production` (for `R.Debug.prod`).
Guard all development-only assertions inside this directive, so they don't get executed at all in the other mode.
```js
R.Debug.dev(function() {
    assert(null !== 0, "Something is very wrong.");
});
```

#### `R.Debug.breakpoint()`
Runs a `debugger` statement.

#### `R.Debug.stackTrace(): String`
Returns a stack trace string.

#### `R.Debug.display(String name, Object obj)`
Pretty-prints a deep inspection of `obj`, iterating over all its properties (even inherited).
Output is wrapped with a clean identifier based on `name`.

#### `R.Debug.fail(Error err)`
Rethrow `err`.

#### `R.Debug.check(...args)`
Calls `assert` with the same arguments `args`. In case of failure, throws in `development` mode,
or outputs with `console.error` in `production` mode.

#### `R.Debug.extendError(Error err, String message): Error err`
Extends an error, augmenting it with an additional message (useful for error catching cascades).
Remember that `if(err) throw err;`/`if(err) return done(err); is an anti-pattern.
Provide useful informations to your caller.

#### `R.Debug.rethrow(String message)`
Returns a node-style callback which simply rethrows the error augmented with `message` using `R.Debug.extendError`.

### `R.App`

A `React on Rails` App represents the top level description of your application.
`App` is a constructor, and an instance of `App` contains:
- a `Flux` constructor,
- a root component constructor,
- a template for the HTML container of your app,
- an asynchronous initializer, executed to perform tasks before rendering the template for a client,
- a collection of template static vars,
- a collection of React on Rails plugins to install on each client,
- a collection of template libs to use as template helpers.

#### `R.App.createApp(Object specs): Function(): new App`

Returns an `App` constructor (a Function that returns an `App` instance when called with `new`) with the provided specs.
- `specs.fluxClass(): new R.Flux` `R.Flux` constructor. A new instance will be created for each client.
- `specs.rootClass(): new ReactComponent`: `ReactComponent` constructor, which should mix in `R.Root.Mixin`. Will be mounted as the root component of the app.
- `specs.template(Object vars, Object libs): String`: a template function which should return the HTML page to send to each client.
You should use `R.App.defaultTemplate` or implement your own very closely.
The `<body>` block of the generated HTML must contain the following blocks:
```html
<div id="ReactOnRails-App-Root">
    <%= vars.rootHtml %>
</div>
```
and
```html
<script type="text/javascript">
    window.__ReactOnRails = {};
    window.__ReactOnRails.serializedFlux = "<%= vars.serializedFlux %>";
    window.__ReactOnRails.serializedHeaders = "<%= vars.serializedHeaders %>";
    window.__ReactOnRails.guid = "<%= vars.guid %>";
</script>
```
for the magic to happen.
- `specs.bootstrapTEmplateVarsInServer*(Object req, Object headers, String guid): Object`: async generator that should return an hash of vars to be passed to the template function.
This is your opportunity to parse request headers or client guid to customize the generated HTML.
- `specs.vars: Object`: optional hash of static vars that will be passed to the template function in addition to the vars computed from `bootstrapTemplateVarsInServer`.
- `specs.plugins: Array|Object`: optional collection of plugins. Plugins are usually created with `R.App.createPlugin` and implement application-wide behaviour, such as `History` or `Cordova`.
- `specs.templateLibs: Object`: optional collection of libs to pass the template function. Defaults to `{ _: require('lodash') }` since `lodash` is so awesome.

#### `R.App#renderToStringInServer*(Object req)` (Server-only)
Async generator that returns the HTML to sent is reponse to a `req` request Object, typically passed by an `express` request handler.
Internally, it does the following:
- generate a fresh `guid`,
- instanciate a new `Flux` instance using `new specs.fluxClass()`,
- asynchronously initialize the flux by yielding `flux.bootstrapInServer(req, req.headers, guid)`,
- install all plugins, invoking `plugin.installInServer(flux, req)` on each,
- prefetch the dependencies of the app by recursively exploring the dependencies of `this.rootClass(props={ flux: flux })`,
- render `this.rootClass(props={ flux: flux })` to string with pre-injected dependencies,
- serialize the flux,
- asynchronously compute additional template vars by yielding `specs.bootstrapTemplateVarsInServer(req)`,
- inject everything into the template to generate the HTML.

#### `R.App#renderIntoDocumentInClient*(window)` (Client-only)
Async generator that mounts the app into the document, reusing the crumbs left by the server-side rendering.
Internally, it does the following:
- instanciate a new `Flux` instance using `new this.specs.fluxClass()`,
- retrieve the `headers` and `guid` from the globals injected by `renderToStringInServer` into `window.__ReactOnRails`,
- asynchronously initialize the flux by yielding `flux.bootstrapInClient(window, headers, guid)`,
- unserialize the flux,
- install all plugins, invoking `plugin.installInClient(flux, window)` on each,
- mount `this.rootClass(props={ flux: flux })` into `window.document.getElementById('ReactOnRails-App-Root')`.

#### `R.App.createPlugin(Object specs): Function(): new Plugin`
Returns a `Plugin` constructor (a Function that returns a new `Plugin` instance when called with `new`) with the provided specs.
`specs.displayName: String`: Name of the plugin, for debugging purposes,
`specs.installInServer*(Flux flux, Object req)`: asynchronously initialize the plugin in the server,
`specs.installInClient*(Flux flux, Object window)`: asynchronously initialize the plugin in the client.

#### `R.App.defaultTemplate`
Sane default template.
Customizable vars:
- `lang: String`: HTML lang, eg. "en". If present, injected into `<html>`'s `lang` attribute. Otherwise this attribute is omitted.
- `charset: String`: meta charset, defaults to `utf-8`. Injected as a `<meta>` inside `<head>`.
- `description: String`: meta description. If present, injected as a `<meta>` inside `<head>`.
- `viewport: String`: meta viewport, defaults to `width=device-width, initial-scale=1`. Injected as a `<meta>` inside `<head>`.
- `title: String`: injected into `<title>`.
- `stylesheets: Array|Object`: collection of stylesheets URL. Each stylesheet results in a `<link rel="stylesheet" type="text/css" />`.
- `scripts: Array|Object`: collection of scripts URL. Each script results in a `<script type="text/javascript">`. You most likely
will need to put the URL to your client build here.

### `R.Client`

A `React on Rails` Client represents the projection of an application in the browser. It's just a containter with only one purpose, mounting an app into
the current window.

#### `R.Client(Function App): new Client` (Client-only)
Constructs a new instance of Client, wrapping an instance of `new App()`.
Upon instantiating, it also attaches the local `React` instance to `window`, allowing the `React dev tools` to work properly in Chrome.
It is the single point of entry of a client.

#### `R.Client#mount*()`
Async generator that mounts an instance of the app into the current window.

### `R.RenderServer`

A `React on Rails` Render Server is in charge of interpreting an HTTP request, render the requested page server-side, and serve it back to the client.
Like `R.Client`, `R.RenderServer` is actually just an `App` containers, leveraging its internal methods to do the heavylifting.

#### `R.RenderServer(Function App): new RenderServer` (Server-only)
Constructs a new instance of RenderServer, wrapping an instance of `new App()`.

#### `R.RenderServer#middleware(Object request, Object response)`
HTTP server/Connect/express middleware that attempts to rendder the page for the given request.
If successful, replies with `200` and the generated HTML. Otherwise, replies with `500` and an error description.

### `R.Flux`

A `React on Rails` Flux is a generalization of the canonical Flux pattern. It encapsulates all the allowed side-effects of an app, such as external data dependencies,
so that all the components are pure with respect to its Flux.
To allow server side rendering to happen, the Flux must be serializable, and constructable either in the server or in the client. Thus, it is designed from the bottom-up
to provide all the required features while remaining serializable and isomorphically constructable.
A Flux instance interfaces 3 collections:
- a collection of stores,
- a collection of event emitters,
- a collection of dispatchers.

Inside an App, each components can interact with the Flux instance using Flux.Mixin (generally via Root.Mixin or Component.Mixin).

#### `R.Flux.createFlux(Object specs): Function(): new Flux`
Returns a `Flux` constructor (a Function which returns a Flux instance when called with `new`) with the provided specs.
- `specs.bootstrapInClient*(Object request, Object headers, String guid)`: Async generator which performs the initialization of the flux in the client.
- `specs.bootstrapInServer*(Object window, Object headers, String guid)`: Async generator which performs the initilization of the flux in the server.
- `specs.destroyInClient()`: (Optional) Free resources allocated in `bootstrapInClient*()`. Defaults to noop.
- `specs.destroyInServer()`: (Optional) Free resources allocated in `bootstrapInServer*()`. Defaults to noop.
It is expected that after bootstrapping on either the client or the server, the state of the flux is the same, ie. ensuring isomorphic semantics.

#### `R.Flux.Mixin: ReactComponentMixin`
React Component Mixin interfacing the current flux.
This mixin expects the component to implement `this.getFlux(): Flux`, which is usually implement by either `R.Root.Mixin` or `R.Component.Mixin`.

#### `R.Flux.Mixin#getFluxStoreSubscriptions(Object props): Object`
Implement this lifecycle method to declare `flux stores -> component state` bindings, defaulting to no bindings (`{}` returned).
For each `(String key, String value)`in the collection (represented by an Object), then:
- `key` is like `storeName:/storeKey`, eg. "myStore://myLocation" means "key `/myLocation` in store named `myStore`".
- `value` is the state key in which the store value will be injected.
For example (using ES6 [computed property keys](https://github.com/lukehoban/es6features#enhanced-object-literals) and [templates strings](https://github.com/lukehoban/es6features#template-strings)):
```js
getFluxStoreSubscriptions(props) {
    return {
        "memory://currentPage": "page",
        [`uplink://user/${props.userId}`]: "user",
    };
}
```
Such a component will have the value keyed by `/currentPage` in the `memory` store injected into `this.state.page`,
and the value keyed by `/user/${props.userId}` in the `uplink` store injected into `this.state.user`.
Note that not only will the values injected at pre-rendering time, but also after mounting, and re-injected whenever the store is updated.
This pattern effectively ensures the automatic liveness of the binding.

Much like `getInitialState`, expect `getFluxStoreSubscriptions` to be called often, so it should be synchronous, fast, and free from side effects.

#### `R.Flux.Mixin#getFluxEventEmittersListeners(Object props): Object`
Similar to `R.Flux.Mixin#getFluxStoreSubscriptions`, but describes bindings of event emitters to callbacks.
For each `(String key, Function value)` in the collection (represented by an Object), then:
- `key` is like `eventEmitterName:/eventEmitterKey`, eg. `myEventEmitter://myEventName` means "key `/myEventName` in event emitter named `myEventEmitter`".
- `value` is the callback function that will be invoked anytime the event is emitted.
For example:
```js
getEventEmittersListeners(props) {
    return {
        "memory://History/navigate": function hasNavigated(params) { console.log("I have navigated to " + params.path); },
    };
}
```

#### `R.Flux.Mixin#fluxStoreWillUpdate(String stateKey, String location, Any val, Any previousVal)`
#### `R.Flux.Mixin#fluxStoreDidUpdate(String stateKey, String location, Any val, Any previousVal)`
#### `R.Flux.Mixin#fluxEventEmitterWillEmit(String eventEmitterName, String eventName, Object params)`
#### `R.Flux.Mixin#fluxEventEmitterDidEmit(String eventEmitterName, String eventName, Object params)`
Callback methods called before/after flux updates/emits, much like `componentWillUpdate` of `componentDidUpdate`.
Under usual circumstances you won't need them, but they can prove handy.

#### `R.Flux.Mixin#dispatch*(String location, Object params)`
Asynchronously dispatches an action. `location` must be like `dispatcherName:/actionName`, eg. `myDispatcher://myAction` represents the
action named `/myAction` in the dispatcher `myDispatcher`.
Be cautious if you do something after yielding, since at this point the component might be unmounted (see `R.Async.Mixin#IfMounted`).

#### `R.Flux#startInjectingFromStores()`
#### `R.Flux#stopInjectingFromStores()`
Sets/unsets the flag telling all the flux-mixed-in components to attempt to inject pre-fetched values from the cache.
Used for pre-rendering magic.
Not intented for public use.

#### `R.Flux#serialize(String str)`
#### `R.Flux#unserialize(): String`
Serializes/unserializes the data inside the flux stores.
Recursively serializes/unserializes each store.
Used for pre-rendering magic.
Not intented for public use.

#### `R.Flux#getStore(String storeName): Store`
#### `R.Flux#registerStore(String storeName, Store store)`
#### `R.Flux#getEventEmitter(String): EventEmitter`
#### `R.Flux#registerEventEmitter(String eventEmitterName, EventEmitter eventEmitter)`
#### `R.Flux#getDispatcher(String dispatcherName): Dispatcher`
#### `R.Flux#registerDispatcher(String dispatcherName, Dispatcher dispatcher)`
Getters/setters for the stores/event emitters/dispatchers of the flux instance.
You probably won't need to use these directly, as location-formatted ("mystore://mykey")
and higher-level method (methods of `R.Flux.Mixin`) are usually preferred.

#### `R.Flux#destroy()`
Clears the store by calling either `this.destroyInServer` or `this.destroyInClient` and
recursively applying `destroy` on each store/event emittre/dispatcher.
Used for pre-rendering magic.
Not intented for public use.

### `R.Store`
A `React on Rails` Store is a generalization of the canonical Flux store. It is an abstract data container, from which
components can read and subscribe. In the canonical Flux, however, the stores are only memory-based: they are basically augmented Objects
used as associative maps. In `React on Rails`, a memory store is only a special case, and a store can be backed not only by a tab-local,
in-memory object, but also by other backends. Most common store backends are memory, HTTP (think of "read-only REST"), and Uplink (think "REST
+ update notifications via WebSocket"). Other backends can easily be implemented, for adapting other containers (LocalStorage, SessionStorage, cookies,
whatever ugly flash API you have to work with, or you own custom data backend).
Store maintain an internal cache, so that after data has been fetched asynchronously, it can be accessed synchronously.
This particular behaviour must be preserved across the serialization/deserialization process, ie if data is fetched, then the store is serialized,
then the store is deserialized, one should still be able to synchronously get the data.
A Store is basically just an API contract. Any object that implement the following methods with the appropriate semantics can be used as a store:
- `displayName: String`: name of the store, required for debugging,
- `fetch*(key): Any`: asynchronously fetch data from the backend.
- `get(key): Any`: assuming that the data has been fetched before, synchronously retrieves the data. If data wasn't fetch, throws in dev mode and returns undefined in prod mode.
- `sub(String key, Function(Any val) signalUpdate): Subscription`: subscribes to the updates of `key`, so that `signalUpdate(val)` is invoked whenever its value is updated. `signalUpdate` will
 be invoked whenever the value is ready after the subscription.
 - `unsub(Subscription sub)`: unsubscribes a previous subscription.
 - `serialize(): String`: serializes the current state of the data cache, preserving `fetch`/`get` semantics.
 - `unserialize(String str)`: unserializes a previously serialized data cache, restoring `fetch`/`get` semantics.
 - `destroy()`: release all allocated resources.

#### `R.Store.createStore(Object specs): Function(): new Store`
Returns a `Store` constructor (a Function which returns a Store instance when called with `new`) with the provided specs.
You probably won't need to call this function if you only want to use predefined Store classes (`MemoryStore`, `HTTPStore` or `UplinkStore`).

#### `R.Store.Subscription(String key): new Subscription`
Constructs a new Subscription instance for the given key. Thin wrapper around:
```
{
    uniqueId: String,
    key: String,
}
```

#### `R.Store.Subscription.uniqueId: String`
Unique identifier for the given subscription. Useful for indexing using associative maps.

#### `R.Store.createMemoryStore(): Function(): new MemoryStore`
Returns a new `MemoryStore` constructor (a Function which returns a MemoryStore instance when called with `new`).
A `MemoryStore` implements the `Store` API, and is meant to represent a memory-local store, eg. navigation,
mouse interactions, etc.
In addition to the `Store` API, it exposes `MemoryStore#set(String key, Any Val)`, which is intented to be invoked
inside a `Dispatcher` to update the store. Components must not use this method directly.

#### `R.Store.createHTTPStore(): Function(Object http): new HTTPStore`
Returns a new `HTTPStore` constructor (a Function which returns an HTTPStore instance when called with `new`).
An `HTTPStore` implements the `Store` API, and is meant to represent a read-only remote store, eg. list of users,
of pages, etc.
The returned constructor expects an `http` argument, which must implement:
- `fetch*(String key): Any` usually wraps an HTTP GET abstraction (consider using (`request`)[https://www.npmjs.org/package/request] for isomorphism).

#### `R.Store.createUplinkStore(): Function(Object uplink): new UplinkStore`
Returns a new `HTTPStore` constructor (a Function which returns a HTTPStore instance when called with `new`).
An `UplinkStore` implements the  `Store` API, and is meant to represent a flux-over-the-wire store, eg. remote store
with automatic updates controlled by server-side dispatchers. It is useful to implement data shared across multiple clients,
eg. chat messages, live feeds, etc.
The returned constructor expects an `uplink` argument, which must implement:
- `fetch*(String key): Any`: retrieve data from the remote uplink server
- `subscribeTo(String key, Function signalUpdate): UplinkSubscription`: subscribe to the updates of `key` to the uplink server (once per store and per key),
- `unsubscribeFrom(String key, UplinkSubscription sub)`: unsubscribe from a previously subscribed key.
An `Uplink` instance is usually created using `new R.Uplink` or `new (R.createUplink(...))`.


### `R.EventEmitter`
A `React on Rails` EventEmitter is very similar to a Store. In fact, EventEmitters are backed by internal mechanisms very close to those used
by the stores. It just provides a slightly different abstraction, that is sometimes more suited. All in all, Event Emitters are event-oriented stores
without persistence. They just forward events.
For example, if you want to trigger an animation every time the user clicks somewhere, then the Event Emitter abstraction is just more suited
that the store abstraction. If you try to implement the same behaviour using only stores, you will end up reinventing the wheel and reimplementing
the Event Emitter pattern inside your stores. True story.

#### `R.EventEmitter.createEventEmitter(Object specs): Function(): new EventEmitter`
Returns a new `EventEmitter` constructor (a Function which returns an EventEmitter instance when called with `new`).
Like a Store, an EventEmitter implements an API contract and must implement:
- `displayName: String`
- `addListener(String eventName, Function emit): Listener`
- `removeListener(Listener listener)`

#### `R.EventEmitter.createMemoryEventEmitter`
Returns a new `MemoryEventEmitter` constructor (a Function which returns a `MemoryEventEmitter` instance when called with `new`).
A `MemoryEventEmitter` implements the `EventEmitter` API, and is meant to represent a memory-local store, eg. clicks, window events, etc.
In addition to the `EventEmitter` API, it exposes `MemoryEventEmitter#emit(String eventName, Object params)`, which is intented to be invoked
inside a `Dispatcher`. Components must not use this method directly.

#### `R.EventEmitter.createUplinkEventEmitter`
Returns a new `MemoryEventEmitter` constructor (a Function which returns an `UplinkEventEmitter` instance when called with `new`).
An `UplinkEventEmitter` implements the `EventEmitter` API, and is meant to represent a remote event emitter, eg. global notifications,
broadcasts, etc.
The returned constructor expecs an `uplink` argument, which must implement:
- `listenTo(String eventName, Function callback): UplinkListener`: listens to the events named `eventName` to the uplink server (once per event emitter and per key),
- `unlistenFrom(String eventName, UplinkListener listener)`: stops listening events named `eventName`.
An `Uplink` instance is usually created using `new R.Uplink` or `new (R.createUplink(...))`.

### `R.Dispatcher`

A `React on Rails` Dispatcher is a generalization of the canonical Flux dispatcher. It acts as a layer of mediation between Stores/EventEmitters ("models") and
components ("views"). This allows for proper control and synchronization. Dispatcher handle (route) actions, with are basically a String identifying the action type,
and an Object encapsulating the action payload. A component may submit an action to a dispatcher, which may or may not dispatch it and perform whatever updates required
(such as updating a MemoryStore or sending a POST request to an Uplink server).
Like stores and event emitters, dispatchers implement the fowllowing API contract:
- actions are dispatched asynchronously and in an opaque manner (no feedback)
- `displayName: String`: useful for debugging
- `addActionListener(String actionName, Function* handler): ActionListener`: register an async action listener
- `removeActionListener(ActionListener listener)`: unregisters a previously added action listener
- `dispatch*(String action, Object params): Array`: asynchronously dispatches an action
- `destroy()`: free side effects

#### `R.Dispatcher.createDispatcher(Object specs): Function(): new Dispatcher`
- `specs.actions: Object`
- `specs.displayName: String`

#### `R.Dispatcher#addActionListener(String action, Function* handler): ActionListener`
#### `R.Dispatcher#removeActionListener(ActionListener listener)`
#### `R.Dispatcher#dispatch*(String action, Object params)`
#### `R.Dispatcher#destroy()`

### `R.Root`

#### `R.Root.Mixin: ReactComponentMixin`
#### `R.Root.Mixin#getFlux(): Flux`

### `R.Component`

#### `R.Component.Mixin: ReactComponentMixin`
#### `R.Component.Mixin#getFlux(): Flux`

### `R.Style: Function(Object reactStyle): new Style`

#### `R.Style.Processors.autoprefixer(String css): String`
#### `R.Style.Processors.min(String css): String`
#### `R.Style.registerCSSProcessor(Function process)`
#### `R.Style.applyAllProcessors(String css): String`
#### `R.Style.slowlyProcessReactStyle(Object reactStyle): Object`
#### `R.Style.getCSSFromReactStyle(Object reactStyle): String`
#### `R.Style.slowlyGetReactStyleFromCSS(String css): Object`

### `R.Stylesheet(): new Stylesheet`

#### `R.Stylesheet#registerRule(String selector, Object reactStyle)`
#### `R.Stylesheet#getProcessedCSS(): String`

### `R.Uplink(String httpEndpoint, String socketEndpoint, String guid, Boolean shouldReloadOnServerRestart): new Uplink`

#### `R.Uplink#ready: Promise()`
#### `R.Uplink#subscribeTo(String key, Function signalUpdate): UplinkSubscription`
#### `R.Uplink#unsubscribeFrom(String key, UplinkSubscription subscription)`
#### `R.Uplink#listenTo(String eventName, Function emit): UplinkListener`
#### `R.Uplink#unlistenFrom(String eventName, UplinkListener listener)`
#### `R.Uplink#fetch(String key): Promise(Any val)`
#### `R.Uplink#dispatch(String action, Object params): Promise(Any res)`
#### `R.Uplink#destroy()`

### `R.SimpleUplinkServer`

#### `R.SimpleUplinkServer.createServer(specs): Function(): new SimpleUplinkServer`
#### `R.SimpleUplinkServer#setStore*(String key, Any val)`
#### `R.SimpleUplinkServer#getStore*(String key): Any`
#### `R.SimpleUplinkServer#emitEvent(String eventName, Object params)`
#### `R.SimpleUplinkServer#emitDebug(String guid, Object params)`
#### `R.SimpleUplinkServer#emitLog(String guid, Object params)`
#### `R.SimpleUplinkServer#emitWarn(String guid, Object params)`
#### `R.SimpleUplinkServer#emitError(String guid, Object params)`
#### `R.SimpleUplinkServer#installHandlers(HttpServer app, String prefix="/uplink/")`
#### `R.SimpleUplinkServer.Connection(Socket socket, Function handleSocketDisconnection, Function linkSession, Function unlinkSession)`
#### `R.SimpleUplinkServer.Connection#guid: null|String`
#### `R.SimpleUplinkServer.Connection#uniqueId: String`
#### `R.SimpleUplinkServer.Connection#emit(String name, Object params)`
#### `R.SimpleUplinkServer.Session(String guid, EventEmitter storeEvent, EventEmitter eventsEvents, EventEmitter sessionsEvents, Number timeout)`
#### `R.SimpleUplinkServer.Session#attachConnection(Connection conn)`
#### `R.SimpleUplinkServer.Session#detachConnection()`
#### `R.SimpleUplinkServer.Session#terminate()`
#### `R.SimpleUplinkServer.Session#subscribeTo(String key)`
#### `R.SimpleUplinkServer.Session#unsubscrimbeFrom(String key)`
#### `R.SimpleUplinkServer.Session#listenTo(String eventName)`
#### `R.SimpleUplinkServer.Session#unlistemFrom(String eventName)`

### `R.Lock(): new Lock`

#### `R.Lock#acquire*()`
#### `R.Lock#release()`
#### `R.Lock#performSync*(Function fn)`
#### `R.Lock#perform*(Function* fn)`

### `React.Children`

#### `React.Children.getChildrenList(ReactDescriptor root): Array(ReactDescriptor)`
#### `React.Children.getDescendantsList(ReactDescriptor root): Array(ReactDescriptor)`
#### `React.Children.mapDescendants(ReactDescriptor root, Function fn(...): T): Array(T)`
#### `React.Children.mapTree(ReactDescriptor root, Function fn(...): T): Array(T)`
#### `React.Children.transformDescendants(ReactDescriptor root, Function fn(...): ReactDescriptor): ReactDescriptor`
#### `React.Children.transformTree(ReactDescriptor root, Function fn(...): ReactDescriptor): ReactDescriptor`

### `React.createClass`

### `R.Pure`

#### `R.Pure.shouldComponentUpdate(Object props, Object state): Boolean`
#### `R.Pure.Mixin: ReactComponentMixin`
#### `R.Pure.Mixin#shouldComponentUpdate(Object props, Object state): Boolean`

### `R.Async`

#### `R.Async.IfMounted(Function fn): Function`
#### `R.Async.Deferred(Function fn, Number delay=0): Function`
#### `R.Async.DeferredImmediate(Function fn): Function`
#### `R.Async.DeferredAnimationFrame(Function fn): Function`
#### `R.Async.Mixin: ReactComponentMixin`
#### `R.Async.Mixin#componentWillMount()`
#### `R.Async.Mixin#componentWillUnmount()`
#### `R.Async.Mixin#setStateIfMounted(Object state)`

### `R.Animate`

#### `R.Animate.Mixin: ReactComponentMixin`
#### `R.Animate.Mixin#componentWillMount()`
#### `R.Animate.Mixin#componentWillUnmount()`
#### `R.Animate.Mixin#isAnimating(String animation): Boolean`
#### `R.Animate.Mixin#getAnimatedStyle(String animation): Object`
#### `R.Animate.Mixin#abortAnimation(String animation)`
#### `R.Animate.Mixin#animate(String animation, Object params)`
- `params.onTick(Object currentStyle, Number t)`
- `params.onComplete(Object currentStyle, Number t)`
- `params.onAbort(Object currentStyle, Number t)`
- `params.easing: String`
- `params.from: Object`
- `params.to: Object`
#### `R.Animate.createInterpolator(Object from, Object to)`
#### `R.Animate.createEasing(String type, Object params={})`
#### `R.Animate.InterpolationTicker(Object params): new InterpolationTicker`
#### `R.Animate.shouldEnableHA(): Boolean`
#### `R.Animate.transformAttributes: Array(String)`
#### `R.Animate.InterpolationTicker#start()`
#### `R.Animate.InterpolationTicker#abort()`

### `R.Query` aka `R.$`

#### `R.$(ReactDescriptor subject) = new $`
#### `R.$#get(): ReactDescriptor`
#### `R.$#type([String type]): String|$` (Getter/Chainable setter)
#### `R.$#prop(String key, [Any val]): Any|$` (Getter or Chainable setter)
#### `R.$#props(Object props|Array(String) keys: Object|$` (Getter/Chainable setter)
#### `R.$#classNameList([Array(String) list]): Array(String)` (Getter/Chainable setter)
#### `R.$#addClassName(String className): R.$` (Chainable)
#### `R.$#removeClassName(String className): R.$` (Chainable)
#### `R.$#hasClassName(String className): Boolean`
#### `R.$#toggleClassName(String className, [Boolean set]): R.$` (Chainable)
#### `R.$#append(ReactDescriptor child): R.$` (Chainable)
#### `R.$#prepend(ReactDescriptor child): R.$` (Chainable)
#### `R.$#transformTree(Function fn): R.$` (Chainable)
#### `R.$#tap(Function fn(ReactDescriptor subject)): R.$` (Chainable)
#### `R.$#walkTree(Function fn(ReactDescriptor each)): R.$` (Chainable)
#### `R.$#end()`

### `R.Router(): new Router`

#### `R.Router#route(String pattern, Function fn): Router` (Chainable)
#### `R.Router#routes(Array(String) patterns): Router` (Chainable)
#### `R.Router#def(Function fn): Router` (Chainable)
#### `R.Router#match(String fragment): Any?`

### `R.History`

#### `R.History.createPlugin(String storeName, String dispatcherName): Function(): new HistoryPlugin @extends R.App.Plugin`
- `${storeName}://History/pathname: String`
- `${dispatcherName}://History/navigate(Object{ pathname: String } params)`

#### `R.History.HistoryPlugin#installInClient()`
#### `R.History.HistoryPlugin#installInServer()`
#### `R.History.createLinkClass(): Function(): new HistoryLink @extends ReactComponent`
#### `R.History.HistoryLink#handleClick`

### `R.Localize`

#### `R.Localize.createPlugin(String storeName, String dispatcherName, Array(String) supportedLocales): Function(): new LocalizePlugin @extends R.App.Plugin`
- `${storeName}://Localize/locale: String`
- `${dispatcherName}://Localize/setLocale(Object{ locale: String } params)`

#### `R.Localize.LocalizePlugin#installInClient()`
#### `R.Localize.LocalizePlugin#installInServer()`
#### `R.Localize.createLocalizeClass(): Function(): new LocalizeLink @extends ReactComponent`
- `props.locale: String`
#### `R.Localize.Localize#handleClick`

### `R.Window`

#### `R.Window.createPlugin(String storeName, String dispatcherName, string eventEmitterName): Function(): new WindowPlugin @extends R.App.Plugin`
- `${storeName}://Window/scrollTop: Number`
- `${storeName}://Window/scrollLeft: Number`
- `${storeName}://Window/height: Number`
- `${storeName}://Window/widht: Number`
- `${dispatcherName}://Window/scrollTo(Object{ top: Number, left: Number } params)`

#### `R.Window.WindowPlugin#installInClient()`
#### `R.Window.WindowPlugin#installInClient()`

### `R.XWindow`

#### `R.XWindow.createPlugin(String storeName, String dispatcherName, string eventEmitterName): Function(): new XWindowPlugin @extends R.App.Plugin`

- `${storeName}://XWindow/: Array(String key)`
- `${dispatcherName}://XWindow/${key}/open(Object { config: Object } params)`
- `${dispatcherName}://XWindow/${key}/close(Object params={})`
- `${dispatcherName}://XWindow/${key}/send(Object { message: Any } params)`
- `${eventEmitterName}://XWindow/${key}/recv(Object { message: Any } params)`
- `${eventEmitterName}://XWindow/${key}/closed`

### `R.Cordova`

#### `R.Cordova.createPlugin(String storeName, String dispatcherName, string eventEmitterName): Function(): new CordovaPlugin @extends R.App.Plugin`

WIP
