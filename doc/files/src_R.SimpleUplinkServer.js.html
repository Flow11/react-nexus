<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\R.SimpleUplinkServer.js - react-rails</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="react-rails"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/R.App.html">R.App</a></li>
            
                <li><a href="../classes/R.Async.html">R.Async</a></li>
            
                <li><a href="../classes/R.Client.html">R.Client</a></li>
            
                <li><a href="../classes/R.Component.html">R.Component</a></li>
            
                <li><a href="../classes/R.Debug.html">R.Debug</a></li>
            
                <li><a href="../classes/R.Dispatcher.html">R.Dispatcher</a></li>
            
                <li><a href="../classes/R.EventEmitter.html">R.EventEmitter</a></li>
            
                <li><a href="../classes/R.Flux.html">R.Flux</a></li>
            
                <li><a href="../classes/R.ReactChildren.html">R.ReactChildren</a></li>
            
                <li><a href="../classes/R.ReactCreateClass.html">R.ReactCreateClass</a></li>
            
                <li><a href="../classes/R.RenderServer.html">R.RenderServer</a></li>
            
                <li><a href="../classes/R.Root.html">R.Root</a></li>
            
                <li><a href="../classes/R.Router.html">R.Router</a></li>
            
                <li><a href="../classes/R.SimpleUplinkServer.html">R.SimpleUplinkServer</a></li>
            
                <li><a href="../classes/R.Store.html">R.Store</a></li>
            
                <li><a href="../classes/R.Store.MemoryStore.html">R.Store.MemoryStore</a></li>
            
                <li><a href="../classes/R.Store.UplinkStore.html">R.Store.UplinkStore</a></li>
            
                <li><a href="../classes/R.Uplink.html">R.Uplink</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\R.SimpleUplinkServer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
module.exports = function(R) {
    var io = require(&quot;socket.io&quot;);
    var _ = require(&quot;lodash&quot;);
    var assert = require(&quot;assert&quot;);
    var co = require(&quot;co&quot;);
    var EventEmitter = require(&quot;events&quot;).EventEmitter;
    var bodyParser = require(&quot;body-parser&quot;);

    /**
    * &lt;p&gt; SimpleUplinkServer represents an uplink-server that will be able to store data via an other server.&lt;br /&gt;
    * There also will be able to notify each client who suscribes to a data when an update will occurs thanks to socket &lt;/p&gt;
    * &lt;p&gt; SimpleUplinkServer will be requested by GET or POST via R.Uplink server-side and client-side
    * @class R.SimpleUplinkServer
    */
    var SimpleUplinkServer = {
        /**
        * &lt;p&gt; Initializes the SimpleUplinkServer according to the specifications provided &lt;/p&gt;
        * @method createApp
        * @param {object} specs All the specifications of the SimpleUplinkServer
        * @return {SimpleUplinkServerInstance} SimpleUplinkServerInstance The instance of the created SimpleUplinkServer
        */
        createServer: function createServer(specs) {
            R.Debug.dev(function() {
                assert(specs.store &amp;&amp; _.isArray(specs.store), &quot;R.SimpleUplinkServer.createServer(...).specs.store: expecting Array.&quot;);
                assert(specs.events &amp;&amp; _.isArray(specs.events), &quot;R.SimpleUplinkServer.createServer(...).specs.events: expecting Array.&quot;);
                assert(specs.actions &amp;&amp; _.isPlainObject(specs.actions), &quot;R.SimpleUplinkServer.createServer(...).specs.actions: expecting Object.&quot;);
                assert(specs.sessionCreated &amp;&amp; _.isFunction(specs.sessionCreated), &quot;R.SimpleUplinkServer.createServer(...).specs.sessionCreated: expecting Function.&quot;);
                assert(specs.sessionDestroyed &amp;&amp; _.isFunction(specs.sessionDestroyed), &quot;R.SimpleUplinkServer.createServer(...).specs.sessionDestroyed: expecting Function.&quot;);
                assert(specs.sessionTimeout &amp;&amp; _.isNumber(specs.sessionTimeout), &quot;R.SimpleUplinkServer.createServer(...).specs.sessionTimeout: expecting Number.&quot;);
            });
            var SimpleUplinkServerInstance = function SimpleUplinkServerInstance() {
                SimpleUplinkServer.SimpleUplinkServerInstance.call(this);
                this._specs = specs;
                this._pid = R.guid(&quot;SimpleUplinkServer&quot;);
            };
            _.extend(SimpleUplinkServerInstance.prototype, SimpleUplinkServer.SimpleUplinkServerInstance.prototype, specs);
            return SimpleUplinkServerInstance;
        },
        /**
        * &lt;p&gt; Setting up necessary methods for the SimpleUplinkServer &lt;/p&gt;
        * @method SimpleUplinkServerInstance
        */
        SimpleUplinkServerInstance: function SimpleUplinkServerInstance() {
            this._store = {};
            this._hashes = {};
            this._storeRouter = new R.Router();
            this._storeRouter.def(_.constant({
                err: &quot;Unknown store key&quot;,
            }));
            this._storeEvents = new EventEmitter();
            this._eventsRouter = new R.Router();
            this._eventsRouter.def(_.constant({
                err: &quot;Unknown event name&quot;,
            }));
            this._eventsEvents = new EventEmitter();
            this._actionsRouter = new R.Router();
            this._actionsRouter.def(_.constant({
                err: &quot;Unknown action&quot;,
            }));
            this._sessions = {};
            this._sessionsEvents = new EventEmitter();
            this._connections = {};

            this._linkSession = R.scope(this._linkSession, this);
            this._unlinkSession = R.scope(this._unlinkSession, this);
        },
        _SimpleUplinkServerInstanceProtoProps: /** @lends R.SimpleUplinkServer.SimpleUplinkServerInstance.prototype */{
            _specs: null,
            _pid: null,
            _prefix: null,
            _app: null,
            _io: null,
            _store: null,
            _storeEvents: null,
            _storeRouter: null,
            _eventsRouter: null,
            _eventsEvents: null,
            _actionsRouter: null,
            _sessions: null,
            _sessionsEvents: null,
            _connections: null,
            bootstrap: null,
            sessionCreated: null,
            sessionDestroyed: null,
            sessionTimeout: null,
            /**
            * &lt;p&gt;Saves data in store.
            * Called by another server that will provide data for each updated data &lt;/p&gt;
            * @method setStore
            * @param {string} key The specified key to set
            * @param {string} val The value to save
            * @return {function} 
            */
            setStore: function setStore(key, val) {
                return R.scope(function(fn) {
                    try {
                        var previousVal = this._store[key] || {};
                        var previousHash = this._hashes[key] || R.hash(JSON.stringify(previousVal));
                        var diff = R.diff(previousVal, val);
                        var hash = R.hash(JSON.stringify(val));
                        this._store[key] = val;
                        this._hashes[key] = hash;
                        this._storeEvents.emit(&quot;set:&quot; + key, {
                            k: key,
                            d: diff,
                            h: previousHash,
                        });
                    }
                    catch(err) {
                        return fn(R.Debug.extendError(err, &quot;R.SimpleUplinkServer.setStore(&#x27;&quot; + key + &quot;&#x27;, &#x27;&quot; + val + &quot;&#x27;)&quot;));
                    }
                    _.defer(function() {
                        fn(null, val);
                    });
                }, this);
            },

            /**
            * &lt;p&gt; Provides data from store. &lt;br /&gt;
            * Called when the fetching data occurs. &lt;br /&gt;
            * Requested by GET from R.Store server-side or client-side&lt;/p&gt;
            * @method getStore
            * @param {string} key The specified key to set
            * @return {function} 
            */
            getStore: function getStore(key) {
                return R.scope(function(fn) {
                    var val;
                    try {
                        R.Debug.dev(R.scope(function() {
                            if(!_.has(this._store, key)) {
                                console.warn(&quot;R.SimpleUplinkServer(...).getStore: no such key (&quot; + key + &quot;)&quot;);
                            }
                        }, this));
                        val = this._store[key];
                    }
                    catch(err) {
                        return fn(R.Debug.extendError(err, &quot;R.SimpleUplinkServer.getStore(&#x27;&quot; + key + &quot;&#x27;)&quot;));
                    }
                    _.defer(function() {
                        fn(null, val);
                    });
                }, this);
            },
            /**
            * @method emitEvent
            * @param {string} eventName
            * @param {object} params
            */
            emitEvent: function emitEvent(eventName, params) {
                this._eventsEvents.emit(&quot;emit:&quot; + eventName, params);
            },
            /**
            * @method emitDebug
            * @param {string} guid
            * @param {object} params
            */
            emitDebug: function emitDebug(guid, params) {
                R.Debug.dev(R.scope(function() {
                    if(this._sessions[guid]) {
                        this._sessions[guid].emit(&quot;debug&quot;, params);
                    }
                }, this));
            },
            /**
            * @method emitLog
            * @param {string} guid
            * @param {object} params
            */
            emitLog: function emitLog(guid, params) {
                if(this._sessions[guid]) {
                    this._sessions[guid].emit(&quot;log&quot;, params);
                }
            },
            /**
            * @method emitWarn
            * @param {string} guid
            * @param {object} params
            */
            emitWarn: function emitLog(guid, params) {
                if(this._sessions[guid]) {
                    this._sessions[guid].emit(&quot;warn&quot;, params);
                }
            },
            /**
            * @method emitError
            * @param {string} guid
            * @param {object} params
            */            
            emitError: function emitLog(guid, params) {
                if(this._sessions[guid]) {
                    this._sessions[guid].emit(&quot;err&quot;, params);
                }
            },
            _extractOriginalPath: function _extractOriginalPath() {
                return arguments[arguments.length - 1];
            },
            _bindStoreRoute: function _bindStoreRoute(route) {
                this._storeRouter.route(route, this._extractOriginalPath);
            },
            _bindEventsRoute: function _bindEventsRoute(route) {
                this._eventsRouter.route(route, this._extractOriginalPath);
            },
            _bindActionsRoute: function _bindActionsRoute(handler, route) {
                this._actionsRouter.route(route, _.constant(R.scope(handler, this)));
            },
            /** 
            * &lt;p&gt; Setting up UplinkServer. &lt;br /&gt;
            * - create the socket connection &lt;br /&gt;
            * - init get and post app in order to provide data via R.Uplink.fetch&lt;/p&gt;
            * @method installHandlers
            * @param {object} app The specified App
            * @param {string} prefix The prefix string that will be requested. Tipically &quot;/uplink&quot;
            */
            installHandlers: function* installHandlers(app, prefix) {
                assert(this._app === null, &quot;R.SimpleUplinkServer.SimpleUplinkServerInstance.installHandlers(...): app already mounted.&quot;);
                this._app = app;
                this._prefix = prefix || &quot;/uplink/&quot;;
                var server = require(&quot;http&quot;).Server(app);
                this._io = io(server).of(prefix);
                this._app.get(this._prefix + &quot;*&quot;, R.scope(this._handleHttpGet, this));
                this._app.post(this._prefix + &quot;*&quot;, bodyParser.json(), R.scope(this._handleHttpPost, this));
                this._io.on(&quot;connection&quot;, R.scope(this._handleSocketConnection, this));
                this._handleSocketDisconnection = R.scope(this._handleSocketDisconnection, this);
                this._sessionsEvents.addListener(&quot;expire&quot;, R.scope(this._handleSessionExpire, this));
                _.each(this._specs.store, R.scope(this._bindStoreRoute, this));
                _.each(this._specs.events, R.scope(this._bindEventsRoute, this));
                _.each(this._specs.actions, R.scope(this._bindActionsRoute, this));
                this.bootstrap = R.scope(this._specs.bootstrap, this);
                yield this.bootstrap();
                return server;
            },
            /**
            * &lt;p&gt;Return the saved data from store&lt;/p&gt;
            * &lt;p&gt;Requested from R.Store server-side or client-side&lt;/p&gt;
            * @method _handleHttpGet
            * @param {object} req The classical request
            * @param {object} res The response to send
            * @param {object} next
            * @return {string} val The computed json value
            */
            _handleHttpGet: function _handleHttpGet(req, res, next) {
                co(function*() {
                    var path = req.path.slice(this._prefix.length - 1); // keep the leading slash
                    var key = this._storeRouter.match(path);
                    R.Debug.dev(function() {
                        console.warn(&quot;&lt;&lt;&lt; fetch&quot;, path);
                    });
                    return yield this.getStore(key);
                }).call(this, function(err, val) {
                    if(err) {
                        if(R.Debug.isDev()) {
                            return res.status(500).json({ err: err.toString(), stack: err.stack });
                        }
                        else {
                            return res.status(500).json({ err: err.toString() });
                        }
                    }
                    else {
                        return res.status(200).json(val);
                    }
                });
            },
            /**
            * @method _handleHttpPost
            * @param {object} req The classical request
            * @param {object} res The response to send
            * @return {string} str
            */
            _handleHttpPost: function _handleHttpPost(req, res) {
                co(function*() {
                    var path = req.path.slice(this._prefix.length - 1); // keep the leading slash
                    var handler = this._actionsRouter.match(path);
                    assert(_.isObject(req.body), &quot;body: expecting Object.&quot;);
                    assert(req.body.guid &amp;&amp; _.isString(req.body.guid), &quot;guid: expecting String.&quot;);
                    assert(req.body.params &amp;&amp; _.isPlainObject(req.body.params), &quot;params: expecting Object.&quot;);
                    if(!_.has(this._sessions, req.body.guid)) {
                        this._sessions[guid] = new R.SimpleUplinkServer.Session(guid, this._storeEvents, this._eventsEvents, this._sessionsEvents, this.sessionTimeout);
                        yield this.sessionCreated(guid);
                    }
                    var params = _.extend({}, { guid: req.body.guid }, req.body.params);
                    R.Debug.dev(function() {
                        console.warn(&quot;&lt;&lt;&lt; action&quot;, path, params);
                    });
                    return yield handler(params);
                }).call(this, function(err, val) {
                    if(err) {
                        if(R.Debug.isDev()) {
                            return res.status(500).json({ err: err.toString(), stack: err.stack });
                        }
                        else {
                            return res.status(500).json({ err: err.toString() });
                        }
                    }
                    else {
                        res.status(200).json(val);
                    }
                });
            },
            /** 
            * &lt;p&gt; Create a R.SimpleUplinkServer.Connection in order to set up handler items. &lt;br /&gt;
            * Triggered when a socket connection is established &lt;/p&gt;
            * @method _handleSocketConnection
            * @param {Object} socket The socket used in the connection
            */
            _handleSocketConnection: function _handleSocketConnection(socket) {
                var connection = new R.SimpleUplinkServer.Connection(this._pid, socket, this._handleSocketDisconnection, this._linkSession, this._unlinkSession);
                this._connections[connection.uniqueId] = connection;
            },

            /** 
            * &lt;p&gt; Destroy a R.SimpleUplinkServer.Connection. &lt;br /&gt;
            * Triggered when a socket connection is closed &lt;/p&gt;
            * @method _handleSocketDisconnection
            * @param {string} uniqueId The unique Id of the connection
            */
            _handleSocketDisconnection: function _handleSocketDisconnection(uniqueId) {
                var guid = this._connections[uniqueId].guid;
                if(guid &amp;&amp; this._sessions[guid]) {
                    this._sessions[guid].detachConnection();
                }
                delete this._connections[uniqueId];
            },

            /** 
            * &lt;p&gt;Link a Session in order to set up subscribing and unsubscribing methods uplink-server-side&lt;/p&gt;
            * @method _linkSession
            * @param {SimpleUplinkServer.Connection} connection The created connection
            * @param {string} guid Unique string GUID
            * @return {object} the object that contains methods subscriptions/unsubscriptions
            */
            _linkSession: function* _linkSession(connection, guid) {
                if(!this._sessions[guid]) {
                    this._sessions[guid] = new R.SimpleUplinkServer.Session(guid, this._storeEvents, this._eventsEvents, this._sessionsEvents, this.sessionTimeout);
                    yield this.sessionCreated(guid);
                }
                return this._sessions[guid].attachConnection(connection);
            },

            /** 
            * &lt;p&gt;Unlink a Session&lt;/p&gt;
            * @method _unlinkSession
            * @param {SimpleUplinkServer.Connection} connection 
            * @param {string} guid Unique string GUID
            * @return {Function} fn
            */
            _unlinkSession: function _unlinkSession(connection, guid) {
                return R.scope(function(fn) {
                    try {
                        if(this._sessions[guid]) {
                            this._sessions[guid].terminate();
                        }
                    }
                    catch(err) {
                        return fn(R.Debug.extendError(&quot;R.SimpleUplinkServerInstance._unlinkSession(...)&quot;));
                    }
                    return fn(null);
                }, this);
            },
            /** 
            * @method _handleSessionExpire
            * @param {string} guid Unique string GUID
            */
            _handleSessionExpire: function _handleSessionExpire(guid) {
                R.Debug.dev(R.scope(function() {
                    assert(_.has(this._sessions, guid), &quot;R.SimpleUplinkServer._handleSessionExpire(...): no such session.&quot;);
                }, this));
                delete this._sessions[guid];
                co(function*() {
                    yield this.sessionDestroyed(guid);
                }).call(this, R.Debug.rethrow(&quot;R.SimpleUplinkServer._handleSessionExpire(...)&quot;));
            },
        },
        /** 
        * &lt;p&gt;Setting up a connection in order to initialies methods and to provides specifics listeners on the socket&lt;/p&gt;
        * @method Connection
        * @param {object} pid 
        * @param {object} socket
        * @param {object} handleSocketDisconnection
        * @param {object} linkSession 
        * @param {object} unlinkSession
        */
        Connection: function Connection(pid, socket, handleSocketDisconnection, linkSession, unlinkSession) {
            this._pid = pid;
            this.uniqueId = _.uniqueId(&quot;R.SimpleUplinkServer.Connection&quot;);
            this._socket = socket;
            this._handleSocketDisconnection = handleSocketDisconnection;
            this._linkSession = linkSession;
            this._unlinkSession = unlinkSession;
            this._bindHandlers();
        },
        _ConnectionProtoProps: /** @lends R.SimpleUplinkServer.Connection.prototype */{
            _socket: null,
            _pid: null,
            uniqueId: null,
            guid: null,
            _handleSocketDisconnection: null,
            _linkSession: null,
            _unlinkSession: null,
            _subscribeTo: null,
            _unsubscribeFrom: null,
            _listenTo: null,
            _unlistenFrom: null,
            _disconnected: null,
            /** 
            * &lt;p&gt;Setting up the specifics listeners for the socket&lt;/p&gt;
            * @method _bindHandlers
            */
            _bindHandlers: function _bindHandlers() {
                this._socket.on(&quot;handshake&quot;, R.scope(this._handleHandshake, this));
                this._socket.on(&quot;subscribeTo&quot;, R.scope(this._handleSubscribeTo, this));
                this._socket.on(&quot;unsubscribeFrom&quot;, R.scope(this._handleUnsubscribeFrom, this));
                this._socket.on(&quot;listenTo&quot;, R.scope(this._handleListenTo, this));
                this._socket.on(&quot;unlistenFrom&quot;, R.scope(this._handleUnlistenFrom, this));
                this._socket.on(&quot;disconnect&quot;, R.scope(this._handleDisconnect, this));
                this._socket.on(&quot;unhandshake&quot;, R.scope(this._handleUnHandshake, this));
            },
            /**
            * &lt;p&gt; Simply emit a specific action on the socket &lt;/p&gt;
            * @method emit
            * @param {string} name The name of the action to send
            * @param {object} params The params 
            */
            emit: function emit(name, params) {
                R.Debug.dev(function() {
                    console.warn(&quot;[C] &gt;&gt;&gt; &quot; + name, params);
                });
                this._socket.emit(name, params);
            },
            /**
            * &lt;p&gt; Triggered by the recently connected client. &lt;br /&gt;
            * Combines methods of subscriptions that will be triggered by the client via socket listening&lt;/p&gt;
            * @method _handleHandshake
            * @param {String} params Contains the unique string GUID
            */
            _handleHandshake: function _handleHandshake(params) {
                if(!_.has(params, &quot;guid&quot;) || !_.isString(params.guid)) {
                    this.emit(&quot;err&quot;, { err: &quot;handshake.params.guid: expected String.&quot;});
                }
                else if(this.guid) {
                    this.emit(&quot;err&quot;, { err: &quot;handshake: session already linked.&quot;});
                }
                else {
                    co(function*() {
                        this.guid = params.guid;
                        var s = yield this._linkSession(this, this.guid);
                        this.emit(&quot;handshake-ack&quot;, {
                            pid: this._pid,
                            recovered: s.recovered,
                        });
                        this._subscribeTo = s.subscribeTo;
                        this._unsubscribeFrom = s.unsubscribeFrom;
                        this._listenTo = s.listenTo;
                        this._unlistenFrom = s.unlistenFrom;
                    }).call(this, R.Debug.rethrow(&quot;R.SimpleUplinkServer.Connection._handleHandshake(...)&quot;));
                }
            },
            /**
            * &lt;p&gt; Triggered by the recently disconnected client. &lt;br /&gt;
            * Removes methods of subscriptions&lt;/p&gt;
            * @method _handleHandshake
            */
            _handleUnHandshake: function _handleUnHandshake() {
                if(!this.guid) {
                    this.emit(&quot;err&quot;, { err: &quot;unhandshake: no active session.&quot;});
                }
                else {
                    co(function*() {
                        this._subscribeTo = null;
                        this._unsubscribeFrom = null;
                        this._listenTo = null;
                        this._unlistenFrom = null;
                        var s = yield this._unlinkSession(this, this.guid);
                        this.emit(&quot;unhandshake-ack&quot;);
                        this.guid = null;
                    }).call(this, R.Debug.rethrow(&quot;R.SimpleUplinkServer.Connection._handleUnHandshake(...)&quot;));
                }
            },
            /** 
            * &lt;p&gt;Maps the triggered event with the _subscribeTo methods &lt;/p&gt;
            * @method _handleSubscribeTo
            * @param {object} params Contains the key provided by client
            */
            _handleSubscribeTo: function _handleSubscribeTo(params) {
                if(!_.has(params, &quot;key&quot;) || !_.isString(params.key)) {
                    this.emit(&quot;err&quot;, { err: &quot;subscribeTo.params.key: expected String.&quot; });
                }
                else if(!this._subscribeTo) {
                    this.emit(&quot;err&quot;, { err: &quot;subscribeTo: requires handshake.&quot; });
                }
                else {
                    this._subscribeTo(params.key);
                }
            },
            /** 
            * &lt;p&gt;Maps the triggered event with the _unsubscribeFrom methods&lt;/p&gt;
            * @method _handleUnsubscribeFrom
            * @param {object} params Contains the key provided by client
            */
            _handleUnsubscribeFrom: function _handleUnsubscribeFrom(params) {
                if(!_.has(params, &quot;key&quot;) || !_.isString(params.key)) {
                    this.emit(&quot;err&quot;, { err: &quot;unsubscribeFrom.params.key: expected String.&quot; });
                }
                else if(!this._unsubscribeFrom) {
                    this.emit(&quot;err&quot;, { err: &quot;unsubscribeFrom: requires handshake.&quot; });
                }
                else {
                    this._unsubscribeFrom(params.key);
                }
            },
            /** 
            * &lt;p&gt;Maps the triggered event with the listenTo methods&lt;/p&gt;
            * @method _handleListenTo
            * @param {object} params Contains the eventName provided by client
            */
            _handleListenTo: function _handleListenTo(params) {
                if(!_.has(params, &quot;eventName&quot;) || !_.isString(params.eventName)) {
                    this.emit(&quot;err&quot;, { err: &quot;listenTo.params.eventName: expected String.&quot; });
                }
                else if(!this._listenTo) {
                    this.emit(&quot;err&quot;, { err: &quot;listenTo: requires handshake.&quot; });
                }
                else {
                    this.listenTo(params.eventName);
                }
            },
            /** 
            * &lt;p&gt;Maps the triggered event with the unlistenFrom methods&lt;/p&gt;
            * @method _handleUnlistenFrom
            * @param {object} params Contains the eventName provided by client
            */
            _handleUnlistenFrom: function _handleUnlistenFrom(params) {
                if(!_.has(params, &quot;eventName&quot;) || !_.isString(params.eventName)) {
                    this.emit(&quot;err&quot;, { err: &quot;unlistenFrom.params.eventName: expected String.&quot; });
                }
                else if(!this.unlistenFrom) {
                    this._emit(&quot;err&quot;, { err: &quot;unlistenFrom: requires handshake.&quot; });
                }
                else {
                    this.unlistenFrom(params.eventName);
                }
            },
             /** 
            * &lt;p&gt;Triggered by the recently disconnected client.&lt;/p&gt;
            * @method _handleDisconnect
            */
            _handleDisconnect: function _handleDisconnect() {
                this._handleSocketDisconnection(this.uniqueId, false);
            },
        },
        /** 
        * &lt;p&gt;Setting up a session&lt;/p&gt;
        * @method Session
        * @param {object} pid 
        * @param {object} storeEvents
        * @param {object} eventsEvents
        * @param {object} sessionsEvents 
        * @param {object} timeout
        */
        Session: function Session(guid, storeEvents, eventsEvents, sessionsEvents, timeout) {
            this._guid = guid;
            this._storeEvents = storeEvents;
            this._eventsEvents = eventsEvents;
            this._sessionsEvents = sessionsEvents;
            this._messageQueue = [];
            this._timeoutDuration = timeout;
            this._expire = R.scope(this._expire, this);
            this._expireTimeout = setTimeout(this._expire, this._timeoutDuration);
            this._subscriptions = {};
            this._listeners = {};
        },
        _SessionProtoProps: /** @lends R.SimpleUplinkServer.Session.prototype */{
            _guid: null,
            _connection: null,
            _subscriptions: null,
            _listeners: null,
            _storeEvents: null,
            _eventsEvents: null,
            _sessionsEvents: null,
            _messageQueue: null,
            _expireTimeout: null,
            _timeoutDuration: null,
            /**
            * &lt;p&gt;Bind the subscribing and unsubscribing methods when a connection is established &lt;br /&gt;
            * Methods that trigger on client issues (like emit(&quot;subscribeTo&quot;), emit(&quot;unsubscribeFrom&quot;))&lt;/p&gt;
            * @method attachConnection
            * @param {SimpleUplinkServer.Connection} connection the current created connection
            * @return {object} the binded object with methods
            */
            attachConnection: function attachConnection(connection) {
                var recovered = (this._connection !== null);
                this.detachConnection();
                this._connection = connection;
                _.each(this._messageQueue, function(m) {
                    connection.emit(m.name, m.params);
                });
                this._messageQueue = null;
                clearTimeout(this._expireTimeout);
                return {
                    recovered: recovered,
                    subscribeTo: R.scope(this.subscribeTo, this),
                    unsubscribeFrom: R.scope(this.unsubscribeFrom, this),
                    listenTo: R.scope(this.listenTon, this),
                    unlistenFrom: R.scope(this.unlistenFrom, this),
                };
            },
            /**
            * &lt;p&gt;Remove the previously added connection, and clean the message queue &lt;/p&gt;
            * @method detachConnection
            */
            detachConnection: function detachConnection() {
                if(this._connection === null) {
                    return;
                }
                else {
                    this._connection = null;
                    this._messageQueue = [];
                    this._expireTimeout = setTimeout(this._expire, this._timeoutDuration);
                }
            },
            /**
            * @method terminate
            */
            terminate: function terminate() {
                this._expire();
            },
            /** 
            * &lt;p&gt;Method invoked by client via socket emit &lt;br /&gt;
            * Store the _signalUpdate method in subscription &lt;br /&gt;
            * Add a listener that will call _signalUpdate when triggered &lt;/p&gt;
            * @method subscribeTo
            * @param {string} key The key to subscribe
            */
            subscribeTo: function subscribeTo(key) {
                R.Debug.dev(R.scope(function() {
                    assert(!_.has(this._subscriptions, key), &quot;R.SimpleUplinkServer.Session.subscribeTo(...): already subscribed.&quot;);
                }, this));
                this._subscriptions[key] = this._signalUpdate();
                this._storeEvents.addListener(&quot;set:&quot; + key, this._subscriptions[key]);
            },

            /** 
            * &lt;p&gt;Method invoked by client via socket emit &lt;br /&gt;
            * Remove a listener according to the key&lt;/p&gt;
            * @method subscribeTo
            * @param {string} key The key to unsubscribe
            */
            unsubscribeFrom: function unsubscribeFrom(key) {
                R.Debug.dev(R.scope(function() {
                    assert(_.has(this._subscriptions, key), &quot;R.SimpleUplinkServer.Session.unsubscribeFrom(...): not subscribed.&quot;);
                }, this));
                this._storeEvents.removeListener(&quot;set:&quot; + key, this._subscriptions[key]);
                delete this._subscriptions[key];
            },
            /**
            * &lt;p&gt; Simply emit a specific action on the socket &lt;/p&gt;
            * @method _emit
            * @param {string} name The name of the action to send
            * @param {object} params The params 
            */
            _emit: function _emit(name, params) {
                R.Debug.dev(function() {
                    console.warn(&quot;[S] &gt;&gt;&gt; &quot; + name, params);
                });
                if(this._connection !== null) {
                    this._connection.emit(name, params);
                }
                else {
                    this._messageQueue.push({
                        name: name,
                        params: params,
                    });
                }
            },
            /** &lt;p&gt;Push an update action on the socket. &lt;br /&gt;
            * The client is listening on the action &quot;update&quot; socket &lt;/p&gt;
            * @method _signalUpdate
            */
            _signalUpdate: function _signalUpdate() {
                return R.scope(function(patch) {
                    this._emit(&quot;update&quot;, patch);
                }, this);
            },
            /** &lt;p&gt;Push an event action on the socket. &lt;br /&gt;
            * The client is listening on the action &quot;event&quot; socket &lt;/p&gt;
            * @method _signalEvent
            */
            _signalEvent: function _signalEvent(eventName) {
                return R.scope(function(params) {
                    this._emit(&quot;event&quot;, { eventName: eventName, params: params });
                }, this);
            },
            /**
            * @method _expire
            */
            _expire: function _expire() {
                _.each(_.keys(this._subscriptions), R.scope(this.unsubscribeFrom, this));
                _.each(_.keys(this._listeners), R.scope(this.unlistenFrom, this));
                this._sessionsEvents.emit(&quot;expire&quot;, this._guid);
            },
            /**
            * &lt;p&gt; Create a listener for the events &lt;/p&gt;
            * @method listenTo
            * @param {string} eventName The name of the event that will be registered
            */
            listenTo: function listenTo(eventName) {
                R.Debug.dev(R.scope(function() {
                    assert(!_.has(this._listeners, key), &quot;R.SimpleUplinkServer.Session.listenTo(...): already listening.&quot;);
                }, this));
                this._listeners[eventName] = this._signalEvent(eventName);
                this._eventsEvents.addListener(&quot;emit:&quot; + eventName, this._listeners[eventName]);
            },
            /**
            * &lt;p&gt; Remove a listener from the events &lt;/p&gt;
            * @method unlistenFrom
            * @param {string} eventName The name of the event that will be unregistered
            */
            unlistenFrom: function unlistenFrom(eventName) {
                R.Debug.dev(R.scope(function() {
                    assert(_.has(this._listeners, eventName), &quot;R.SimpleUplinkServer.Session.unlistenFrom(...): not listening.&quot;);
                }, this));
                this._eventsEvents.removeListener(&quot;emit:&quot; + eventName, this._listeners[eventName]);
                delete this._listeners[eventName];
            },
        },
    };

    _.extend(SimpleUplinkServer.SimpleUplinkServerInstance.prototype, SimpleUplinkServer._SimpleUplinkServerInstanceProtoProps);
    _.extend(SimpleUplinkServer.Connection.prototype, SimpleUplinkServer._ConnectionProtoProps);
    _.extend(SimpleUplinkServer.Session.prototype, SimpleUplinkServer._SessionProtoProps);

    return SimpleUplinkServer;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
