

React on Rails - The Ultimate React Framework
=============================================

React on Rails has a simple goal: make it easy for you to deliver production-ready full stack web apps on top of React.
React on Rails fully embraces the core design choices of React from the bottom to the top.

# Core features

- Full-stack by default. Write logic once, get pre-rendering for free and without jsdom/PhantomJS/node-fibers black magic. And I mean asynchronous pre-rendering. With data-fetching even in complex dependencies setups. Automagically. Yup.
- Production-ready performance. React is all about elegance that actually improves performance.
- Batteries included. React on Rails comes bundled with a set of must-have features optimized for React, including React CSS Style autoprefixing, Animations, Routing, History, i18n.
- Backend-agnostic. Use one or several data backends to power your Flux: memory, HTTP REST, localStorage, WebSockets, or easily write your own adapter.

## Also included

- REAL TIME BY DEFAULT/FLUX OVER THE WIRE: Client and simple server for Uplink, a custom micro-protocol on top of HTTP and socket.io to achieve production-ready real-time data propagation. Client components trigger actions, server dispatchers update server-side stores, and client components get updated.
- Exensible CSS processor for React CSS Style processing.
- Extensions of React.Children to allow jQuery-like manipulation of Children.
- Generic Router, an extension of Regular Expression commonly used for URL and messages routing.
- Many useful debugging/typechecking tools that can be globally opted-out when going to production, without any code modification, only raw performance gain.
- Plug-and-play asynchronous utilities to deal with timeouts and stuff without blowing everything up.

## Core principles

- App logic is either directly in components (for local logic) or in the Flux dispatchers (for global logic). Since we only want to write app logic once, components and dispatchers
behaviour should be fully ismorphic (ie. run both on the client and the server) wherever it makes sense.
- All code is isomorphic by default. Some escape hatches are provided to allow client- or server-specific behaviour (eg. events listeners in the client, CSS preprocessing in the server), but they are always explicit. Unless passed a specific reference to window, always assume you might very well be running on the server.
- Everything is pure with respect to some context. In React on Rails, in addition to `props` and `state`, we have `flux`, which encapsulates global app state.
The `flux` is bootstrapped before the page is first rendered, and is then updated by actions. It always remains serializable, and thus can be bootstrapped server-side before being recovered client-side.
- Since everything is encapsulated in a serializable flux, then all components can be pure and benefit from the almighty heuristics of React's `shouldComponentUpdate`.

### Design choices

Like React, React on Rails strongly relies on its strong and opiniated design choices to achieve usability and performance. Among which:
- It uses generators. A lot. You should consider using them, too. See `regenerator`.
- Unless explicitly specified, all code is assumed to be isomorphic, except:
    - Code executed after `componentDidMount`.
    - Dispatchers callbacks (dispatchers aren't even mounted server-side).
    - Code guarded with either `R.isServer()` or `R.isClient()`.
- You don't *have* to, but full-JS extremism is supported: in React on Rails, you won't need to write a single line outside of JS files. Your JS will be CommonJS, your HTML will be JS, and even your CSS will be JS.

### Understanding the React on Rails flow

A React on Rails app usually consists in code executed in three distinct locations:
- The clients' browser, running its JS engine.
- The render server, running node.
- Zero, one or more backend servers, running whichever you use. React on Rails comes with a simple but powerful implementation of Uplink, which exposes its Stores and Dispatchers in REST, and pushes stores and events updates using WebSockets (socket.io actually).

The flow is then:

- Client requests an URL from the render server. Say, /index.
- Render server starts mounting the app server side. It creates a fresh flux instance and populates it with data from the HTTP headers.
- Render server then starts to prefetch the data dependencies of the app. To do so, it asynchronously renders the root React component of the app, fetches its dependencies, and recursively fetch the dependencies until all dependencies are met.
- Whenever it needs, the backend server(s) replies to data queries.
- Once the data dependencies are fulfilled, the render server synchronously renders the app and creates a fully structured HTML. This HTML includes:
    - The HTML generated by React,
    - The stylesheets programmatically declared by components, processed (using autoprefixer, cssmin, etc) and inlined in `<style>` inside `<head>`.
    - The serialized flux, embedding the whole app state.
- The client receives the already-rendered app. It revives its flux instance using the serialized data, mounts the Root components of the app, and automagically subscribes to all stores updates. Data that has updated in between is directly updated.

### Bootstrapping a React on Rails app

A React on Rails app consists in the following components:
- An R.App class definition, referencing a full page HTML template, a React Root component class, and an R.Flux class definition.
- An R.Flux class definition, describing how to bootstrap the flux on the server. This includes one or several R.Store/R.EventEmitter/R.Dispatcher class definitions.
- A client-only and a render-server-only entry points (just to avoid shipping non-isomorphic code to either).
- Optionally, an R.UplinkServer class definition, if you chose to use an Uplink data backend server. A simple but efficient implementation is shipped in R.SimpleUplinkServer.
- You React components, of course. Mix R.Root.Mixin to your Root component class and R.Component.Mixin to any other component class to enjoy all the goodness of React on Rails.

### Data, events, and actions in React on Rails

Aside from props, components in React on Rails can depend on a global encapsulated state named the flux.
The flux hosts:
- One or several instances of R.Store,
- One or several instances of R.EventEmitter,
- One or several instances of R.Dispatcher,
- As a convenience, one or several instance of R.Stylesheet (although they are actually static, they are app-wide configuration-level).

- An R.Store represent data that components can depend on, much like props. From the components, a Store is read-only, but may be updated by "the outside world" (see below). Components can subscribe to a specific resource in a Store, so that its value is injected into its state, and udpated automatically.
- An R.EventEmitter is almost like a store, except no value is cached. EventEmitters are just a convenient way to handle some stateless stuff. Think of them like a special kind of store.
- An R.Dispatcher is the opposite of a Store. From the components, an R.Dispatcher is a black-box they can send (dispatch) actions to. Typically, a Dispatcher may update the backend of a Store, indirectly triggering an update of one or several components. Actions are always dispatched asynchronously.

To facilitate manipulation of multiple stores/eventEmitters/dispatchers, React on Rails implements a very simple scheme similar to URLs: the string `<name>:/<path>` represents a reference to the given path relative to the given name.

For example, inside an R.Component:

`yield this.dispatch("uplink://sayHello", { hello: "world" });` will forward the "/sayHello" action to the "uplink" dispatcher, and pass it `{ hello: "world "}` as params.
`getFluxStoreSubscriptions: function() { return { "memory://Localize/locale": "locale"; }; }` will declare the value inside "/Localize/locale" from the `memory` store as a dependency to inject into the `locale` state key.

### Plugins

React on Rails provides a consistent framework to reason about to deploy application-wide behaviour.
This kind of application-wide takes the form of R.App.Plugin class definitions, and define how a plugin hooks into an App.

React on Rails comes with the following plugins:
- Localize: easily internationalize an entire app. Enables using directives such as `<Localize locale="en-US" key="a"><span>Hello</span></Localize><Localize locale="fr-FR" key="b"><span>Bonjour</span></Localize>` and exposed the current locale in a Memory Store as /Localize/locale.
- History: consistently handle History in an isomorphic and HTML5-friendly way. Sets up and manages /History/pathname and /History/route (is a Router is also passed) in a Memory Store.
- Fullscreen: consistently handle fullscreen. Sets up and manages /Fullscreen/isFullscreen and dispatches /Fullscreen/startFullscreen and /Fullscreen/stopFullscreen.
- Window: consistently handle window.resize, window.height, etc. Sets up and manages /Window/height, /Window/width, /Window/scrollTop, /Window/scrollLeft, /Window/title, /Window/meta in stores, /Window/resize, /Window/scroll in events, and dispatches /Window/resize, /Window/scrollTo, /Window/setTitle, and /Window/setMeta.
- XWindow: consistently handle window.postMessage. Sets up and manages /XWindow/windows in stores, /XWindow/:window in events, and dispatches /XWindow/:window/postMessage.
- Connection: consistently handle online/offline status. Sets up and manages /Connection/status in stores, /Connection/connect, /Connection/disconnect in events.
- Power: consistently handle power status. Sets up and manages /Power/status.

### Uplink: Flux over the wire

The most simple flux implementations are backed by a local hash-map like feature, usually a raw Object, localStorage or sessionStorage. However, since action dispatching is asynchronous anyway, it is absolutely feasible to back the flux by a remote implementation of the opaque flux logic. Uplink is an extremely simple protocol mixing REST and RPC principles in JSON to implement this feature.
Namely:
- From the components point of view, an Uplink Store/EventEmitter/Dispatcher is just like any memory-backed Store/EventEmitter/Dispatcher.
- An Uplink Server implements the Store/EventEmitter/Dispatcher API.
    - GET `<path>` exposes the `<path>` key of the store,
    - POST `<path>` { params as json } exposes the `<path>` action of the dispatcher,
    - WebSocket (actually socket.io) implements signaling both ways: client subscribes to updates, and gets notified whenever the remote store is updated.
- Unline traditional REST, Uplink is actually stateful. Each client is uniquely and securedly identified by a guid key, which allows for the implementation of authentication or other schemes.

TL;DR: Uplink makes client-server synchronization as easy as client-memory synchronization. It just works.


## React on Rails Goodness Examples ##

The following component is a simple scale dice. Whenever the button is clicked, the Uplink server dispatches the "/setRandomScale" action with the { in: [1, 2, 3]} params, which will set the uplink store "/currentScale" value to either "1", "2", or "3". Upon changing this value, the div will smoothly transition to the new scale. The CSS style is injected in the top-level stylesheet statically at pre-rendering time. The button is also dynamically localized.

```js
var R = require("react-rails");
var styles = {
    1: R.Style.slowlyProcessReactStyle({ transform: "scale(1)" }), // automatically vendor-prefix everything under the hood
    2: R.Style.slowlyProcessReactStyle({ transform: "scale(2)" }), // other CSS transforms can be plugged in
    3: R.Style.slowlyProcessReactStyle({ transform: "scale(3)" }),
};

var ScaleDice = React.createClass({
    mixins: [R.Component.Mixin, R.Localize.Mixin("memory", "dispatcher")], // Declare the referenced store and dispatcher
    statics: {
        getStylesheetRules: function getStylesheetRules() { // lifecycle method called by R
            return {
                "main": {
                    ".ScaleDice": {
                        backgroundColor: "black", // automatically vendor-prefixed/bundled/minified
                        color: "white",           // at server pre-rendering time; not evaluated at client runtime
                        height: 200,
                        width: 1000,
                    },
                    ".ScaleDice > button": {
                        width: 200,
                        height: 40,
                        textAlign: "center",
                        marginLeft: "auto",
                        marginRight: "auto",
                        marginTop: 100,
                    },
                },
            };
        },
    },
    getInitialState: function getInitialState() {
        return {
            currentScale: 1,
        };
    },
    getFluxStoreSubscriptions: function getFluxStoreSubscriptions(props) { // props unused here but available if needed
        return {
            "uplink://currentScale": "currentScale",
            "memory://Localize/locale": "currentLocale",
        };
    },
    fluxStoreWillUpdate: function fluxStoreWillUpdate(stateKey, location, nextVal, curVal) { // lifecycle method called by R
        if(nextVal !== curVal) {
            this.transitionToScale(curVal, nextVal);
        }
    },
    transitionToScale: function transitionToScale(fromScale, toScale) {
        this.animate("transition", { // animate method from R.Component.Mixin (delegated to R.Animate.Mixin.animate)
            from: styles[fromScale],
            to: styles[toScale],
            duration: 1000,
            easing: "cubic-in-out", // Any of d3's easing can be used
        }); // no need to worry about aborting/canceling the animation; all is handled by R.Animate.Mixin
    },
    setRandomScale: function(event) {
        event.preventDefault();
        co(function*() { // co+generator allows to use yield, but its optionnal, simple thunks can be used
            yield this.dispatch("uplink://setRandomScale", { in: [1, 2, 3] }); // dispatch method from R.Component.Mixin (delegated to R.Flux.Mixin.dispatch)
        }).call(this);
    },
    // implicitly pure mixin (shouldComponentUpdate delegated to R.Pure.Mixin from R.Component.Mixin)
    render: function render() { // style and localization is dynamic
        var setRandomScale = this.setRandomScale;
        var style = this.isAnimating("transition") ? this.getAnimatedStyle("transition") : styles[this.state.currentScale]);
        // For the record, this.state.currentLocale contains the current locale, although its not used here.
        return (<div className="ScaleDice" style={style}>
            <Localize locale="en-US" key="en-US">
                <button onClick={setRandomScale}>Click to set random scale</button>
            </Localize>
            <Localize locale="fr-FR" key="fr-FR">
                <button onClick={setRandomScale}>Cliquer pour une échelle aléatoire</button>
            </Localize>
        </div>);
    },
});
```



### API Reference

#### Top-level API
##### Utilities

#### R.Animate
##### Animating stuff the React Way

#### R.App
##### Bootstrapping a React on Rails App

#### R.Async
##### Dealing with Asynchrony without breaking everything

#### R.Client
##### React on Rails Client

#### R.Component
##### Batteries-included React on Rails Component Mixin

#### R.Debug
##### No-compromise debugging utilies

#### R.Dispatcher
##### Generic Flux Dispatcher for React on Rails

#### R.EventEmitter
##### Abstract Flux EventEmitter for React on Rails. Include implementations of MemoryEventEmitter and UplinkEventEmitter.

#### R.Flux
##### Generic Flux for React on Rails

#### R.History
##### History plugin to implement HTML5 navigation consistently

#### R.Localize
##### Localization plugin to implement i18n consistently

#### R.Pure
##### Generic Pure Mixin

#### R.Query/R.$
##### jQuery-like manipulation and transformation of descriptors

#### R.ReactChildren
##### Extension/monkey-patch of React.Children backing R.Query

#### R.ReactCreateClass
##### Extension/monkey-patch of React.createClass

#### R.RenderServer
##### React on Rails Render Server

#### R.Root
##### Batteries-included React on Rails Root Mixin

#### R.Router
##### Generic Router, implementing generalized URL/keys/events/actions matching

#### R.Store
##### Abstract Flux Store EventEmitter for React on Rails. Include implementations of MemoryStore and UplinkStore.

#### R.Style
##### Style manipulation and processing the React Way

#### R.Stylesheet
##### Generic Flux Stylesheet for React on Rails

#### R.Uplink
##### Uplink Client for React on Rails
